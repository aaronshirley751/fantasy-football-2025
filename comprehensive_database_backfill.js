const fs = require('fs');

// Supabase configuration - Updated with working credentials
const supabaseUrl = 'https://jfeuobfjgqownybluvje.supabase.co';
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpmZXVvYmZqZ3Fvd255Ymx1dmplIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU1NTI1ODUsImV4cCI6MjA3MTEyODU4NX0.7qu0h_cKNpdW1ZENZ3652LE75MC6VQp9Ahu5SSDypuY';
const supabaseServiceKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpmZXVvYmZqZ3Fvd255Ymx1dmplIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NTU1MjU4NSwiZXhwIjoyMDcxMTI4NTg1fQ.TYZBL4UNLEJN6ovM6HQS5wxm2zkbZHBYtmQYALHDkqQ';

const LEAGUE_ID = '1249067741470539776'; // Sleeper league ID
const DATABASE_LEAGUE_UUID = 'a7d65b53-2ec5-4b38-94ee-7fcb97160989'; // Database UUID

async function loadAuditResults() {
    console.log('üìã Loading audit results...');
    
    try {
        const auditData = JSON.parse(fs.readFileSync('comprehensive_audit_results.json', 'utf8'));
        console.log(`‚úÖ Loaded audit results from ${new Date(auditData.audit_date).toLocaleString()}`);
        return auditData;
    } catch (error) {
        console.error('‚ùå Failed to load audit results:', error.message);
        console.log('üîß Please run comprehensive_all_rosters_audit.js first');
        process.exit(1);
    }
}

async function fetchPlayerName(playerId) {
    // Simple cache to avoid repeated API calls
    if (!fetchPlayerName.cache) {
        fetchPlayerName.cache = {};
    }
    
    if (fetchPlayerName.cache[playerId]) {
        return fetchPlayerName.cache[playerId];
    }
    
    try {
        // Check if it's a team defense (2-3 character code)
        if (playerId.length <= 3 && playerId.toUpperCase() === playerId) {
            fetchPlayerName.cache[playerId] = `${playerId} DEF`;
            return `${playerId} DEF`;
        }
        
        const response = await fetch(`https://api.sleeper.app/v1/player/${playerId}`);
        if (response.ok) {
            const player = await response.json();
            const name = player.full_name || `${player.first_name || ''} ${player.last_name || ''}`.trim() || `Player ${playerId}`;
            fetchPlayerName.cache[playerId] = name;
            return name;
        }
    } catch (error) {
        // Fallback for failed API calls
    }
    
    fetchPlayerName.cache[playerId] = `Player ${playerId}`;
    return `Player ${playerId}`;
}

async function createTransactionRecord(transaction, rosterInfo) {
    const roster_id = rosterInfo.roster_id;
    
    // Calculate fee (matches the Edge Function logic)
    let fee_amount = 0;
    if (['waiver', 'free_agent'].includes(transaction.type)) {
        // For now, we'll calculate fees properly after we know how many transactions each roster has
        // This will be updated by the Edge Function logic later
        fee_amount = 2; // Default fee per transaction (will be recalculated by Edge Function)
    }
    
    return {
        league_id: DATABASE_LEAGUE_UUID, // Use the database UUID
        roster_id: roster_id,
        sleeper_transaction_id: transaction.transaction_id,
        type: transaction.type,
        week_number: transaction.leg || null, // Sleeper week if available
        fee_amount: fee_amount,
        processed: false // Will be processed by Edge Function later
        // Note: created_at will be auto-generated by database
    };
}

async function insertTransactionsBatch(transactions) {
    console.log(`üì§ Inserting batch of ${transactions.length} transactions...`);
    
    try {
        const response = await fetch(`${supabaseUrl}/rest/v1/transactions`, {
            method: 'POST',
            headers: {
                'apikey': supabaseServiceKey,
                'Authorization': `Bearer ${supabaseServiceKey}`,
                'Content-Type': 'application/json',
                'Prefer': 'return=minimal,resolution=ignore-duplicates'
            },
            body: JSON.stringify(transactions)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`‚ùå Failed to insert batch: ${response.status} ${response.statusText}`);
            console.error('Response:', errorText);
            return false;
        }
        
        console.log(`‚úÖ Successfully inserted ${transactions.length} transactions`);
        return true;
        
    } catch (error) {
        console.error('‚ùå Error inserting batch:', error);
        return false;
    }
}

async function backfillTransactions(auditResults) {
    console.log('\nüîß STARTING COMPREHENSIVE DATABASE BACKFILL');
    console.log('=' .repeat(80));
    
    let totalInserted = 0;
    let totalErrors = 0;
    const batchSize = 10; // Process in smaller batches to avoid timeouts
    
    for (const [rosterId, rosterData] of Object.entries(auditResults.audit_results)) {
        if (rosterData.missing_count === 0) {
            console.log(`‚úÖ ${rosterData.owner_name}: No missing transactions`);
            continue;
        }
        
        console.log(`\nüë§ Processing ${rosterData.owner_name} (${rosterData.missing_count} transactions)`);
        console.log('-'.repeat(60));
        
        const transactions = [];
        
        // Process each missing transaction
        for (const transaction of rosterData.missing_transactions) {
            try {
                const record = await createTransactionRecord(transaction, {
                    roster_id: parseInt(rosterId),
                    owner_name: rosterData.owner_name
                });
                
                transactions.push(record);
                console.log(`üìù Prepared: ${transaction.type} transaction ID ${transaction.transaction_id} (${new Date(transaction.created).toLocaleDateString()})`);
                
            } catch (error) {
                console.error(`‚ùå Error preparing transaction ${transaction.transaction_id}:`, error);
                totalErrors++;
            }
        }
        
        // Insert in batches
        for (let i = 0; i < transactions.length; i += batchSize) {
            const batch = transactions.slice(i, i + batchSize);
            const success = await insertTransactionsBatch(batch);
            
            if (success) {
                totalInserted += batch.length;
                console.log(`‚úÖ Inserted ${batch.length} transactions for ${rosterData.owner_name}`);
            } else {
                totalErrors += batch.length;
                console.log(`‚ùå Failed to insert ${batch.length} transactions for ${rosterData.owner_name}`);
            }
            
            // Small delay between batches
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }
    
    console.log('\n' + '='.repeat(80));
    console.log('üìä BACKFILL SUMMARY');
    console.log('=' .repeat(80));
    console.log(`‚úÖ Total Transactions Inserted: ${totalInserted}`);
    console.log(`‚ùå Total Errors: ${totalErrors}`);
    console.log(`üí∞ Total Fees Now Available: $${Object.values(auditResults.audit_results).reduce((sum, r) => sum + r.missing_fees, 0)}`);
    
    return {
        inserted: totalInserted,
        errors: totalErrors
    };
}

async function validateBackfill() {
    console.log('\nüîç VALIDATING BACKFILL RESULTS');
    console.log('=' .repeat(40));
    
    try {
        const response = await fetch(`${supabaseUrl}/rest/v1/transactions?select=count()`, {
            headers: {
                'apikey': supabaseServiceKey,
                'Authorization': `Bearer ${supabaseServiceKey}`,
                'Content-Type': 'application/json'
            }
        });
        
        if (response.ok) {
            const result = await response.json();
            const count = result[0]?.count || 0;
            console.log(`üìä Total transactions in database: ${count}`);
            return count;
        } else {
            console.error('‚ùå Failed to validate backfill');
            return 0;
        }
    } catch (error) {
        console.error('‚ùå Error validating backfill:', error);
        return 0;
    }
}

async function main() {
    try {
        console.log('üöÄ Starting Comprehensive Database Backfill');
        console.log(`üìÖ Date: ${new Date().toLocaleString()}`);
        console.log('=' .repeat(80));
        
        // Load audit results
        const auditData = await loadAuditResults();
        
        // Show summary
        const totalMissing = Object.values(auditData.audit_results).reduce((sum, r) => sum + r.missing_count, 0);
        const totalFees = Object.values(auditData.audit_results).reduce((sum, r) => sum + r.missing_fees, 0);
        
        console.log(`üö® Total Missing Transactions: ${totalMissing}`);
        console.log(`üí∞ Total Missing Fees: $${totalFees}`);
        console.log(`üèà League: ${auditData.league_id}`);
        
        // Confirm before proceeding
        console.log('\n‚ö†Ô∏è  This will add ALL missing transactions to the database.');
        console.log('üîß Proceeding with backfill...\n');
        
        // Execute backfill
        const results = await backfillTransactions(auditData);
        
        // Validate results
        const finalCount = await validateBackfill();
        
        console.log('\n‚úÖ BACKFILL COMPLETE!');
        console.log(`üìä Expected ${totalMissing} transactions, database now has ${finalCount} transactions`);
        
        if (finalCount >= totalMissing) {
            console.log('üéâ Backfill appears successful!');
            console.log('üîß The Edge Function should now process fees correctly.');
        } else {
            console.log('‚ö†Ô∏è  Some transactions may be missing. Check logs above for errors.');
        }
        
    } catch (error) {
        console.error('‚ùå Backfill failed:', error);
    }
}

main();